# Verilog Cheatsheet

## 基本语法

### 标识符、常量和注释

#### 标识符

- 所描述对象的名字称为“标识符”；标识符可包含字母、数字、下划线和 $ 符号；以字母或下划线开头。

#### 常量

- 整数常量表示方式：`<size>'<base><value>`；可通过下划线来分割数字，提升可读性。
- `value` 中除了数字以外，还可以包含 `x`（非法值或不定态，0/1 之间电压值）、`z`（浮空值或高阻态，导线悬空）

#### 注释

同 C/C++.

### 数据类型

- 网线类型（net，提供元件或模块之间的物理连接）：如 `wire`.
- 寄存器类型（register，抽象的存储元件）：`reg`；在给寄存器赋予新值之前，寄存器将保存上一次的赋值结果，这与触发器和锁存器的性质类似。
- 参数类型（parameter）：给常量赋予有意义的标识符（const）
- 向量和数组：`reg[MSB:LSB] <memory_name> [first_addr:last_addr]`，即定义了一个从 `MSB` 到 `LSB` 的向量，然后以这个向量为元素开了一个数组，索引为 `first_addr` 到 `last_addr`.

#### 模块端口函数

- 输入端口：
    - 在模块定义时，模块的输入端口被看作父模块到子模块输入端口的物理连接，所以只能定义为 `wire` 类型。
    - 在模块实例化时，可将子模块输入端口关联的父模块信号看成物理连接的驱动源，可以为 `wire` 类型或 `reg` 类型。
    - 输出端口既可以是 `wire` 也可以是 `reg`.
    - 如果定义输入输出没有说明数据类型，缺省为 `wire`.

### 运算符

- `&a`：将数组 `a` 中所有元素与起来
- 位拼接：`{a, {2{c, b}}} = {a, c, b, c, b}`

其余语法和 C 语言类似。



## Verilog 建模方式

### 结构化建模

1. 模块及结构化建模：即用户自己设计子模块。
2. 门级结构化建模：通过逻辑运算等语法，调用 Verilog 内建的基本门级元件
3. 开关级结构化建模

### 数据流建模（assign）

`assign 网线 = 表达式`

- 将右边的输出作为左边的输入

- 左边必须为 `wire`，右边都行

- 从物理结构来理解，**赋值语句的顺序 doesn't matter，这也是我们必须从硬件角度研究语言的原因**。

    ```verilog
    assign a = b + c;
    assign b = c & d;
    
    assign b = c & d;
    assign a = b + c;
    // 上面两组赋值没有区别
    ```

- 不能对相同的网线进行重复的驱动（即两个不同的 assign）

- 不能出现回路

### 行为建模

`always @ (事件信号列表) 过程语句`

- 过程语句中被赋值的只能是 `reg` 类型变量。

- 事件信号列表多个信号用 `,` 分隔，用关键字 `posedge/negedge` 来修饰，表示只检测上升沿或者下降沿。

    ```verilog
    always @ (posedge clk)
        q <= d
    // 当 clk 信号上升沿到来时，将 d 的值更新到 reg 变量 q
    ```

    事件信号列表也可以用 `*`，表示所有要用到的信号列表，就是说所有会影响这个模块运行的信号发生变化时，就会执行这个模块。

#### 行为建模中的过程语句

- `begin/end`：视为左花括号、右花括号。
- 阻塞赋值语句：`reg = expression`，在赋值语句结束以后立即更新（可用于描述组合逻辑电路）
- 非阻塞赋值语句：`reg <= expression`，在整个 always 结束以后并行更新（可用于描述时序逻辑电路）

**Verilog 语言允许再一个 always 语句中对同一个 reg 类型变量进行多次赋值，并以最后一次赋值为准，但不能在多个 always 语句里面对同一个 reg 类型变量进行赋值！**（这相当于多个电路逻辑同时连向同一个寄存器，相当于两个 assign，所以不行）

- case 语句：

```verilog
case (expr0)
    expr1: statement1
    expr2: statement2
    [default: statement] //可以不给出
endcase
```

- 循环语句：

```verilog
for(expr1; expr2; expr3) statement
```

语法和 C 语言相同，从硬件的角度来理解，不应该理解成电路在时间上重复，而应该理解成在空间上重复构建多个电路。
