# 近似算法

- PTAS：Poly-Time Approx Scheme，多项式时间近似算法。
- EPTAS：在 PTAS 的基础上，要求 A 的复杂度是 $O(|I|^c)f(1/\epsilon)$，即 A 的运行时间和问题规模 $|I|$ 呈简单的多项式关系，与近似比无关。
- FPTAS：要求 A 的运行时间关于 $|I|$ 还有 $1/\epsilon$ 都呈多项式关系，即复杂度为 $|I|^{O(1)} (1/\epsilon)^{O(1)}$.

## 装箱问题

- **NextFit**: 第二个能够和第一个装进箱子就装，否则开一个新的
  - 假设 $M$ 是最优解，NextFit 最多用 $2M - 1$ 个箱子
  
- **FirstFit**: 查找之前所有装过东西的箱子，装到第一个能装进去的，没有就开一个新的
  - 假设 $M$ 是最优解，FirstFit 最多用 $\dfrac{17M}{10}$ 个箱子，可以构造序列让 FirstFit 使用 $\dfrac{17(M - 1)}{10}$ 个箱子
  
- **BestFit**: 查找之前所有装过东西的箱子，装到装进去后最满的那个箱子里，没有就开一个新的
  - 时间复杂度 $T(N) = O(N \log N)$
  - 假设 $M$ 是最优解，BestFit 最多用 $\dfrac{17M}{10}$ 个箱子
  
- 不存在近似比优于 $\dfrac{3}{2}$ 的算法：

> 使用反证法，如果存在近似比小于 $\dfrac{3}{2}$ 的算法，那么可以用这个算法 $A$ 来解决 NPC 的判断物品是否可以由两个箱子装下的问题。
>
> - 如果物品可以由两个箱子装下，那么 $\text{OPT} = 2$，则 $A(I) < \dfrac{3}{2} \cdot 2 = 3$，即 $A(I) < 3$；此时 $A(I) = 2$，那么 $A$ 可以判断；
>
> - 如果物品不可以由两个箱子装下，那么 $\text{OPT} \geq 3$，则 $A(I) \geq 3$；但是由于近似比小于 $\dfrac{3}{2}$，所以由 $A(I)$ 可以判断此时 $\text{OPT}$ 不可能是 2。此时这个近似算法 $A$ 就可以判断物品是否可以由两个箱子装下。
>
> 综上，我们用多项式算法 $A$ 来解决 NPC 问题，所以只可能有 $\text{P} = \text{NP}$。

## 背包问题——分数形式

- 你可以选择装一个物品的一定比例，而非全部装入，还是求背包内的总价值最大的装法
- 贪心算法：近似比为 2

## K-center 问题

- 在一个点集中，找k个点，使得所有点到这些点的最小距离组成的集合中的最大值最小。
- 贪心算法：近似比为 2，没有近似比更小的算法