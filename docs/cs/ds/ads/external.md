# 外部排序

如果数据输入在磁带上，由于磁带只能被顺序访问，所以适合用于外部排序的排序算法是归并排序。

## 简单做法

![Image title](assets/simple-1735520090382-11.png)

假设一开始数据存储在磁带 $T_1$ 上，外部内存容量是 3，则依次读取 3 个数据为一组，交替放在磁带 $T_2$ 和 $T_3$ 上，然后按对应归并 $T_2$ 和 $T_3$ 上的数据，结果交替放在 $T_1$ 和 $T_4$ 上，然后重复这个过程，直到所有数据都排序完成。

- run: 每组排好序的数据称为一个run
- pass: 将所有数据读过一遍的称为一个pass

## K-way Merge

![Image title](assets/kway.png)

k 路合并有一个实现上需要注意的点，因为我们是 k 个顺串要合并，因此我们需要不断的在 k 个元素中选取最小值放到输出的磁带上，这个操作可以使用优先队列来实现。

## 多相合并

为了优化多路合并对于磁带数的成本，我们考虑多相合并，这种方法对于多路合并的磁带成本可以从 $2k$ 减少到 $k + 1$。

![Image title](assets/mul1.png)

这种方法就是每次均分，然后合并，然后再均分合并……但是需要较多的复制合并次数，不优秀。

我们考虑斐波那契数列，发现这样是最优秀的。

如果 run 个数不足，就用哑串来补足斐波那契。

将上述算法应用到 k-way merge，则需要 k 阶斐波那契数。

定义为

$$
F^{(k)}(n) = F^{(k)}(n-1) + F^{(k)}(n-2) + \cdots + F^{(k)}(n-k)
$$

且

$$
F^{(k)}(0) = F^{(k)}(1) = \cdots = F^{(k)}(k-2) = 0, \quad F^{(k)}(k-1) = 1
$$
经过第一个 pass 初始化之后，$k+1$ 个 tape 的结构如下：

$$
\begin{aligned}
\text{tape1}: & \ F^{(k)}(n-1) + F^{(k)}(n-2) + \cdots + F^{(k)}(n-k+1) + F^{(k)}(n-k) \\
\text{tape2}: & \ F^{(k)}(n-1) + F^{(k)}(n-2) + \cdots + F^{(k)}(n-k+1) \\
\text{tape3}: & \ F^{(k)}(n-1) + F^{(k)}(n-2) + \cdots \\
\vdots & \ \\
\text{tapek}: & \ F^{(k)}(n-1) \\
\text{tape(k+1)}: & \ 0
\end{aligned}
$$

然后合并，结果放在 $tape(k+1)$ 上，结果如下，发现符合之前的结构，可以继续向下递归。

$$
\begin{aligned}
\text{tape1}: & \ F^{(k)}(n-2) + F^{(k)}(n-3) + \cdots + F^{(k)}(n-k) \\
\text{tape2}: & \ F^{(k)}(n-2) + F^{(k)}(n-3) + \cdots + F^{(k)}(n-k+1) \\
\text{tape3}: & \ F^{(k)}(n-2) + F^{(k)}(n-3) + \cdots \\
\vdots & \ \\
\text{tapek}: & \ 0 \\
\text{tape(k+1)}: & \ F^{(k)}(n-1) = F^{(k)}(n-2) + F^{(k)}(n-3) + \cdots + F^{(k)}(n-k-1)
\end{aligned}
$$