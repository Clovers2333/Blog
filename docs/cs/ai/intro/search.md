# 搜索与求解

## 搜索算法基础

搜索算法的形式化描述如下：

- 状态：$S$，表示问题的状态空间；
- 动作：$A$，表示问题的动作空间；
- 状态转移：$f(s, a)$，表示状态 $s$ 经过动作 $a$ 转移到的下一个状态；
- 路径/代价：$g(s, a)$，表示从初始状态到状态 $s$ 经过动作 $a$ 的代价；
- 目标测试：$goal(s)$，表示判断状态 $s$ 是否为目标状态。

### 评价指标
- 完备性：能否找到解（不一定最优）
- 最优性：能否保证找到的第一个解是最优解
- 时间复杂度（通过扩展的结点数量衡量）
- 空间复杂度（通过同时记录的结点数量衡量）

| 符号 | 含义                                       |
| ---- | ------------------------------------------ |
| b    | 分支因子，即搜索树中每个节点最大的分支数目 |
| d    | 根节点到最浅的目标结点的路径长度           |
| m    | 搜索树中路径的最大可能长度                 |
| n    | 状态空间中状态的数量                       |

### 算法框架
```assembly
F <- {根节点}
while F != ∅ do
    n <- pick_from(F)
    F <- F - {n}
    if goal_test(n) then
        return n.path
    end
    F <- F ∪ successor_nodes(n)
end
```

- pick_from 决定扩展结点的顺序，successor_nodes 决定哪些节点可被放入边缘集合（fringe set，也叫开表，open list）以在后面扩展（expand）
- 每次从边缘集合中取出最上层（最浅）的结点时是广度优先搜索（breadth first search，BFS）
- 每次从边缘集合中取出最下层（最深）的结点时是深度优先搜索（depth first search，DFS）
- 放弃扩展部分结点的做法称为剪枝（pruning）

## 启发式搜索

- 利用启发函数（heuristic function）来指导搜索的过程，以期望更快地找到解。
- 启发函数 $h(n)$，用来评估从结点 $n$ 到目标结点的代价，启发函数通常非负。
- 对于结点 $n$，启发函数 $h(n)$ 的值越小，说明结点 $n$ 越接近目标结点，优先级越高。